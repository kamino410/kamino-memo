# ソートアルゴリズム1

## サンプルプログラム

次のような`swap`関数と`main`関数が用意される前提で書く。

```cpp
void swap(int* a, int* b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main(void) {
  int data[] = {8, 1, 5, 0, 2, 3, 6, 9, 7, 4};

  //sort(data, 10);
  for (int i = 0; i < 10; i++)
    cout << data[i] << endl;
  return 0;
}
```

## ソートアルゴリズムに関する用語

### 内部整列と外部整列

すべての対象データが主記憶領域にある状態で行うソートを**内部整列（internal sort）**、一部のデータしか主記憶領域に置くことができない状態で行うソートを**外部整列（external sort）**と呼ぶ。

一般的に外部整列ではシーケンシャルアクセスに重きを置いたアルゴリズムを用いることで外部記憶領域のデータへのアクセスを高速化する。

### 安定なソート

ソート対象に同じ値を持つ要素が存在するとき、その並び順がソートの前後で変化しないことが保証されるものを**安定なソートアルゴリズム**と呼ぶ。

このページでは特に言及しない限り安定なアルゴリズムである。

### 分割統治法（divide and rule / divide and conquer）

対象となる問題を小さな問題に分割し、それをすべて解くことで元の問題を解決する手法。
ソートに限らず、アルゴリズムの世界でよく用いられる。

## 単純なアルゴリズム

### バブルソート（bubble sort）

隣り合う要素の大小を比較し並べ替えることを繰り返すアルゴリズム。

前から順に比較して昇順に並べ替えることにすると、1回目の比較で$$n$$番目（最後）の要素が最も大きな値を取り、値が確定する。よって2回目は$$n-1$$番目の要素までを比較すればよい。3回目以降も同様と考えれば、最終的に $$\sum_{i_1}^{n-1}\sum_{j=1}^{n-1}(n-j)=n(n-1)/2$$ 回の比較でソートが完了する。

* 時間計算量：$$O(n^2)$$
* 空間計算量：$$O(1)$$

```cpp
void bubble_sort(int *arr, int len){
  //前から確定していくように、昇順に並べ替える例
  for (int i = len - 1; i > 0; i--)
    for (int j = 0; j < i; j++)
      if (data[j] > data[j + 1])
        swap(&(data[j]), &(data[j + 1]));
}
```

### 選択ソート（selection sort）

未整列の領域に対して、そのうちで最小の要素を先頭に持ってくることを繰り返すアルゴリズム。

前から処理を進めて昇順に並べ替える場合、次のような手順によって実現できる。

1. 未整列の領域 $$a[i] \sim a[n]$$ のうち最小の要素$$a[p]$$を見つけ、$$a[p]$$と$$a[i]$$を入れ替える
2. $$a[i+1] \sim a[n]$$ 以降に対して同様の操作を繰り返す

最終的に $$\sum_{i_1}^{n-1}\sum_{j=1}^{n-1}(n-j)=n(n-1)/2$$ 回の比較でソートが完了する。

* 時間計算量：$$O(n^2)$$
* 空間計算量：$$O(1)$$

```cpp
void selection_sort(int *arr, int len){
  //前から確定していくように、昇順に並べ替える例
  for (int i = 0; i < len; i++)
    for (int j = i; j < len; j++)
      if (arr[i] > arr[j])
        swap(&(arr[i]), &(arr[j])); //簡易化のため先頭より小さい要素を見つけた時点でswapしている
}
```

### 挿入ソート（insertion sort）

未整列の要素を1つ取り出し、整列済みの領域の適切な位置に挿入することを繰り返すアルゴリズム。

* 平均時間計算量：$$O(n^2)$$
* 空間計算量：$$O(1)$$

```cpp
void insertion_sort(int *arr, int len){
  //前側を整列済みとして昇順に並べ替える例
  for (int i = 0; i < len; i++) {
    int j = i;
    while (i > 0 && arr[j - 1] > arr[j]) {
      swap(&(arr[j - 1]), &(arr[j]));
      j--;
    }
  }
}
```

### シェルソート（Shell sort）

挿入ソートを改良したアルゴリズム。改良挿入ソートとも。

ソート前後の要素の移動量の総和は $$\sum_{i=1}^n \sum_{j=1}^n |i-j| \simeq \frac{n^2}{3} = O(n^2)$$ である。
隣り合う要素の比較を繰り返す限り時間計算量は $$O(n^2)$$ を超える。

そこで、あらかじめ $$h$$ 離れた要素同士を比較・交換する**$$h$$-ソート**を行ってから、挿入ソートを実行するのがシェルソートである。

手順は以下の通り。

1. 幅 $$h$$ を適当に決定する
2. $$h$$ 離れた要素同士を比較・交換する作業を1周させる
3. $$h$$ を小さくして上記の手順を繰り返す
4. $$h=1$$ のソートが終わったら挿入ソートを実行する

ただし、正確な時間計算量を求める問題は未解決である。実験的な手法により $$h_i=\frac{3^i-1}{2}$$ としたとき、平均時間計算量が $$O(n^{1.25})$$ になることがわかっているため、これを利用することが多い。

* 平均時間計算量：$$O(n^{1.25})$$
* 空間計算量：$$O(1)$$

```cpp
void insertion_sort(int *arr, int len) {
  for (int i = 0; i < len; i++) {
    int j = i;
    while (i > 0 && arr[j - 1] > arr[j]) {
      swap(&(arr[j - 1]), &(arr[j]));
      j--;
    }
  }
}

//昇順に並び替える例
void shell_sort(int *arr, int len) {
  int h;
  for (h = 1; h < len / 9; h = h * 3 + 1)
    ;

  for (; h > 0; h /= 3) {
    for (int i = h; i < len; i++) {
      int j = i;
      while (j >= h && arr[j - h] > arr[j]) {
        swap(&(arr[j]), &(arr[j - h]));
        j -= h;
      }
    }
  }

  insertion_sort(arr, len);
}
```
