# 文字列探索（string searching）

ある文字列に特定の文字列が含まれているかの探索を行うアルゴリズムについて言及する。

## ナイーブな探索（brute-force algorithm）

最も単純なアルゴリズムは以下の手順で実現できる。

1. 検索対象の先頭と検索ワードの先頭を重ねて比較する
2. 重ねる位置を1つずらして比較する
3. 2を繰り返す
4. 検索対象の末尾と検索ワードの末尾が重なったらその回で終了

* 探索の計算量は検索対象の長さ（$$n$$）と検索ワードの長さ（$$m$$）に比例
  * 平均計算量は$$O(mn)$$

## KMP法（Knuth Morris Pratt algorithm）

brute-force algorithmを改良し、何文字目で不一致になったかをもとに次の照合開始位置を決めるようにしたアルゴリズム。

KMP法では探索の前に検索ワードから、「その文字位置で不一致になったとき次の照合位置を何文字分ずらすか」という情報を格納したテーブルを生成する（細かい部分は実装により異なる）。

* テーブルの作成
  * 時間計算量：$$O(m^2)$$
* 探索
  * 時間計算量：$$O(n)$$

ただし1回あたりの処理が重くなる上、一般的な文字列では部分的にでも一致することは稀なため、実用上はナイーブなアルゴリズムとほとんど差がない。

### テーブルの作成

テーブルTは検索ワード同士（A,Bとする）の比較により作成する。
比較の際に`1+T[i]`ずらすようにテーブルの値を決めることにする。
以下に手順を示す。

1. 1文字目で失敗したら1文字ずらすことにする`T[0]=0`
2. 検索ワードA,Bを $$k$$ 文字ずらして重ね合わせる
    * 先頭が一致しなければ`T[k]=0`
    * 一致するところまで`T[k]=1, T[k+1]=2, ...`とする

>例：検索ワードが`ABABCA`のとき

>* 1文字目
>    * `T[0]=0`

>* 2文字目
>    * `ABABCA`
>    * `.ABABCA`
>    * 1文字も一致しないので`T[1]=0`
>* 3文字目
>    * `ABABCA`
>    * `..ABABCA`
>    * 2文字目・3文字目が一致するので`T[2]=1, T[3]=2`
>* 5文字目
>    * `ABABCA`
>    * `....ABABCA`
>    * 1文字も一致しないので`T[4]=0`
>* 6文字目
>    * `ABABCA`
>    * `.....ABABCA`
>    * 1文字目が一致するので`T[5]=1`

>よって`T=[001201]`となる。

### 比較

1. 検索対象の先頭と検索ワードの先頭を重ねて比較する
2. 重ねる位置を1つずらして比較する
    * 不一致の場合、不一致になった位置とテーブルを照らし合わせて次の照合位置を求める
3. 2を繰り返す
4. 検索対象の末尾と検索ワードの末尾が重なったらその回で終了

>例：検索ワードが`ABABCA`のとき

>例えば`ABCDEFGAB…`から`ABABCA`を検索するとき、1回目の比較で2文字目まで一致し3文字目が不一致になる。

>`T[2]=1`なので、2文字分ずらして`BCDEFG`との比較はスキップして`CDEFGA`との比較に進む。

## BM法（Boyer-Moore algorithm）

KMP法を改良し、照合の際に不一致になった文字に応じて次の照合位置を決めるアルゴリズム。
照合の際に検索ワードに含まれない文字が末尾に出現すれば $$m-1$$ 回の照合をスキップできるため実用的にも性能がよい。

* 最悪時間計算量：$$O(n)$$
* 平均時間計算量：$$O(n/m)$$

※実装方法により異なる

### テーブル作成

ASCII文字が対象の場合は、各文字について「最後尾で不一致の場合何文字ずらすか」のテーブル`T`を作成する。

検索ワードに含まれる文字は「末尾から何文字目」であるかの値を求め、最も小さいものを`T[ch]`に格納する。
検索ワードに含まれない文字は検索ワードの長さ $$m$$ を`T[ch]`に格納する。

マルチバイトの場合、文字の分だけメモリを確保するわけにいかないため工夫が必要になる。

>例：検索ワードが`ABABCA`のとき

>`ABCDEFG…a…z`

>`0216666…6…6`

### 比較

1. 検索対象の先頭と検索ワードの先頭を重ねて末尾の文字から順に比較する
    * 不一致の場合、「不一致になった文字とテーブルを照らし合わせて得た値」ー「不一致になった位置の末尾からの距離」を次の照合位置とする（負になった場合は1文字だけずらす）
2. 1を繰り返す
3. 検索対象の末尾と検索ワードの末尾が重なったらその回で終了

>例：検索ワードが`ABABCA`のとき

>例えば`ABCDEFGHIABABCATRS…`から`ABABCA`を検索するとき、

>* 1回目

>`ABCDEF`と`ABABCA`を比較する。末尾が不一致で、不一致文字`F`のテーブル上の値は`T['F']=6`なので6文字ずらす。

>* 2回目

>`GHIABA`と`ABABCA`を比較する。末尾から1文字目が不一致で、不一致文字`B`のテーブル上の値は`T['B']=2`なので3文字ずらす

>`ABABCA`と`ABABCA`を比較する。一致したので一致判定を下す。複数探索なら1文字ずらして次の判定に進む。
