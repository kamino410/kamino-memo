# ソートアルゴリズム

## サンプルプログラム

次のような`swap`関数と`main`関数が用意される前提で書く。

```cpp
void swap(int* a, int* b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main(void) {
  int data[] = {8, 1, 5, 0, 2, 3, 6, 9, 7, 4};

  //sort(data, 10);
  for (int i = 0; i < 10; i++)
    cout << data[i] << endl;
  return 0;
}
```

## ソートアルゴリズムに関する用語

### 内部整列と外部整列

すべての対象データが主記憶領域にある状態で行うソートを**内部整列（internal sort）**、一部のデータしか主記憶領域に置くことができない状態で行うソートを**外部整列（external sort）**と呼ぶ。

一般的に外部整列ではシーケンシャルアクセスに重きを置いたアルゴリズムを用いることで外部記憶領域のデータへのアクセスを高速化する。

### 安定なソート

ソート対象に同じ値を持つ要素が存在するとき、その並び順がソートの前後で変化しないことが保証されるものを**安定なソートアルゴリズム**と呼ぶ。

## 単純なアルゴリズム

### バブルソート（bubble sort）

隣り合う要素の大小を比較し並べ替えることを繰り返すアルゴリズム。

前から順に比較して昇順に並べ替えることにすると、1回目の比較で$$n$$番目（最後）の要素が最も大きな値を取り、値が確定する。よって2回目は$$n-1$$番目の要素までを比較すればよい。3回目以降も同様と考えれば、最終的に $$\sum_{i_1}^{n-1}\sum_{j=1}^{n-1}(n-j)=n(n-1)/2$$ 回の比較でソートが完了する。

* 時間計算量：$$O(n^2)$$
* 空間計算量：$$O(0)$$

```cpp
void bubble_sort(int *arr, int len){
  //前から確定していくように、昇順に並べ替える例
  for (int i = len - 1; i > 0; i--)
    for (int j = 0; j < i; j++)
      if (data[j] > data[j + 1])
        swap(&(data[j]), &(data[j + 1]));
}
```

### 選択ソート（selection sort）

未整列の領域に対して、そのうちで最小の要素を先頭に持ってくることを繰り返すアルゴリズム。

前から処理を進めて昇順に並べ替える場合、次のような手順によって実現できる。

1. 未整列の領域 $$a[i] \sim a[n]$$ のうち最小の要素$$a[p]$$を見つけ、$$a[p]$$と$$a[i]$$を入れ替える
2. $$a[i+1] \sim a[n]$$ 以降に対して同様の操作を繰り返す

最終的に $$\sum_{i_1}^{n-1}\sum_{j=1}^{n-1}(n-j)=n(n-1)/2$$ 回の比較でソートが完了する。

* 時間計算量：$$O(n^2)$$
* 空間計算量：$$O(0)$$

```cpp
void selection_sort(int *arr, int len){
  //前から確定していくように、昇順に並べ替える例
  for (int i = 0; i < len; i++)
    for (int j = i; j < len; j++)
      if (arr[i] > arr[j])
        swap(&(arr[i]), &(arr[j])); //簡易化のため先頭より小さい要素を見つけた時点でswapしている
}
```

### 挿入ソート（insertion sort）

未整列の要素を1つ取り出し、整列済みの領域の適切な位置に挿入することを繰り返すアルゴリズム。

* 平均時間計算量：$$O(n^2)$$
* 空間計算量：$$O(0)$$

```cpp
void insertion_sort(int *arr, int len){
  //前側を整列済みとして昇順に並べ替える例
  for (int i = 0; i < len; i++) {
    int j = i;
    while (i > 0 && arr[j - 1] > arr[j]) {
      swap(&(arr[j - 1]), &(arr[j]));
      j--;
    }
  }
}
```
