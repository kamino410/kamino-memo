# ヒープ・プライオリティキュー

**プライオリティキュー** は蓄えた値のうち最大（最小）のものをpopできるキュー。

**ヒープ** は「親ノードの値 ≧ or ≦ 子ノードの値」となる木構造。二分木で実装されたヒープを特に二分ヒープと呼ぶ。

プライオリティキューはヒープによって実装可能である。

* 計算量は木の深さに比例
  * 平均計算量は$$O(\log n)$$

## 実装

C++の場合は標準ライブラリの`queue`に`priority_queue<T>`が用意されている。

## プライオリティキューを用いて解ける問題の例

```
ガソリンは距離1に対して1消費する、ガソリンタンク容量が無制限のトラックにガソリンがPだけ積まれている。
このトラックで距離Lの道を移動する。
道の途中には距離A_iの地点にB_iのガソリンを持ったガソリンスタンドがある。
トラックは移動を燃料切れせず移動を完了できるか？また最小で何回の給油が必要か？
```

この問題は次の手順で解くことができる。

1. 次のガソリンスタンドに移動できるか判定する。
   * 移動できた場合、そこで給油できるガソリン量をプライオリティキューにpushする。
   * 移動できない場合、プライオリティキューからこれまで通過したガソリンスタンドのうちガソリン量の最も多いものをpopし、そこで給油していたことにする。
2. 上記の手順を繰り返す。

## 実装例

```cpp
#include <iostream>
#include <queue>

using namespace std;

int main(void) {
  int n = 4, l = 25, p = 10;
  //簡単にするためゴールもガソリンスタンドのリストに追加する
  int stations[][2] = {{10, 10}, {14, 5}, {20, 2}, {21, 4}, {25, 0}};

  //--------------------

  priority_queue<int> pq;
  int curpos = 0, ans = 0, tank = p;

  for (int i = 0; i < n + 1; i++) {
    int d = stations[i][0] - curpos;
    while (tank - d < 0) {
      if (pq.empty()) {
        cout << "-1" << endl;
        return 0;
      }
      tank += pq.top();
      pq.pop();
      ans++;
    }
    tank -= d;
    curpos = stations[i][0];
    pq.push(stations[i][1]);
  }

  cout << ans << endl;

  return 0;
}
```
