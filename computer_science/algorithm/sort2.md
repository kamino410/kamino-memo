# ソートアルゴリズム2

## 分割統治法によるソート

### クイックソート（quick sort）

基準の値（pivot）を設定し、それより大きい要素の領域・同じ値の要素の領域・小さい要素の領域に分割する作業を繰り返すアルゴリズム。安定でないソートアルゴリズムになる。

以下の手順による実装が有名。昇順に並び替える例。

1. 対象領域をpivotより大きい要素の領域・同じ値の要素の領域・小さい要素の領域に分割する
    1. 適当な値をpivotとして選択する
        * 対象領域の中央値が望ましいが計算コストが高い
        * ランダムに1つ選ぶ、ランダムに3つ選んで中央値を取る、などの実装が多い
    2. 対象領域の両端にポインターを置く
    3. pivot以上の値が現れるまで前のポインターを後ろに進める
    4. pivot以下の値が現れるまで後ろのポインターを前に進める
    5. 前のポインター・後ろのポインターの位置の値を入れ替える
    6. 2つのポインターが交差するまで1~5を繰り返す
2. 分割した2つの領域に対して上の作業を行う

現在発見されている内部整列のアルゴリズムとしては最速。
ただし、pivotとして選択した値が領域内の最大値・最小値であった場合、単なる選択ソートになるため最悪時間計算量は $$O(n^2)$$となる。
ソート対象の性質や状態によっては他のアルゴリズムの方が早くなる。

* 平均時間計算量：$$O(n\log n)$$
* 最悪時間計算量：$$O(n^2)$$
* 最良時間計算量：$$O(n\log n)$$
* 最悪空間計算量：$$O(n)$$ ※ただし再帰のためにcall stackを消費するだけ

```cpp
// l:最初のindex, r:最後のindex
void recursion(int *arr, int l, int r) {
  if (l >= r)
    return;

  // 先頭・中央・末尾の中央値をpivotに
  int p;
  int x = arr[(r + l) / 2], y = arr[l], z = arr[r];
  p = x < y ? (y < z ? y : z < x ? x : z) : (z < y ? y : x < z ? x : z);
  
  int lp = l, rp = r;

  while (true) {
    while (arr[lp] < p)
      lp++;
    while (arr[rp] > p)
      rp--;
    if (lp >= rp)
      break;
    swap(&(arr[lp]), &(arr[rp]));
    lp++;
    rp--;
  }
  recursion(arr, l, lp - 1);
  recursion(arr, rp + 1, r);
}

void quick_sort(int *arr, int len) { recursion(arr, 0, len - 1); }
```

### マージソート（merge sort）

対象領域を分割し、それぞれをソートした後1つにまとめる（**マージ**する）アルゴリズム。
マージは小領域の先頭の要素同士を比較し最も小さいもの（大きいもの）を選ぶ作業となる。

対象データ容量の倍の記憶領域が必要なかわり、シーケンシャルアクセスによって実装できるため、外部整列に適している。
実用的には、主記憶領域が許す容量まで分割しクイックソートなどでソートした後、外部記憶領域を利用しながらマージを行う。

最悪時間計算量のオーダーはクイックソートに勝るが、分割が多く1段階あたりの計算量が多いため、通常クイックソートのほうが早い。

* 最悪時間計算量：$$O(n\log n)$$
* 最良時間計算量：$$O(n\log n)$$
* 平均時間計算量：$$O(n\log n)$$
* 最悪空間計算量：$$O(n)$$

```cpp
void merge(int *arr1, int len1, int *arr2, int len2, int *res) {
  int i1 = 0, i2 = 0;
  for (int i = 0; i < len1 + len2; i++) {
    if (i1 == len1)
      res[i] = arr2[i2++];
    else if (i2 == len2)
      res[i] = arr1[i1++];
    else
      res[i] = arr1[i1] > arr2[i2] ? arr2[i2++] : arr1[i1++];
  }
}

int main(void) {
  int data[] = {8, 1, 5, 0, 2, 3, 6, 9, 7, 4};
  int res[10];

  // 前後に分割し、それぞれをクイックソートしたあとでマージ
  quick_sort(data, 5);
  quick_sort(data + 5, 5);
  merge(data, 5, data + 5, 5, res);
  
  for (int i = 0; i < 10; i++)
    cout << res[i] << endl;
  return 0;
}
```
