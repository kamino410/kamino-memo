# ナイーブな探索

## 深さ優先探索（DFS : Depth-First Search）

縦型探索とも。

1. 開始ノードから子ノードを辿っていく
1. 子ノードが途切れれば親ノードに戻って別の子ノードを辿る
1. 求めるノードに辿りついたら終了

という手順で解を探索する。
明示的に検証待ちのノードを記録するリストを作成する場合、これを**OPENリスト**と呼ぶことがある。

探索対象がグラフの場合はループが存在する可能性があるため、検証済みのノードを記録する**CLOSEDリスト**を導入し、辿った先のノードが検証済みであるかを確認しながら探索する。

### 特徴

* 再帰関数で簡単に記述できることが多い
* メモリの消費量が少ない
* 深さ無限の場合、解に辿りつける保証がない
* コストを考慮した探索対象の絞り込み・優先順位付けなどは行わない

単にすべての状態を列挙したいときは実装が楽なのでDFSを使うことが多い。

### 実装

再帰関数もしくは、LIFO（Last-In First-Out）のデータ構造つまりスタックをOPENリストとして実装する。

※再帰関数は本質的にはスタックを利用した深さ優先探索の実装の一種と言える

```cpp

```

## 幅優先探索（BFS : Breadth-First Search）

横型探索とも。

1. 開始ノードを1層目、その子ノードを2層目、さらにその子ノードを3層目...とする
1. 1層目の全てのノード、2層目の全てのノード...を順に検証していく
1. 求めるノードに辿りついたら終了

という手順で解を探索する。
探索対象がグラフの場合は深さ優先探索同様にOPENリスト・CLOSEDリストを導入し、辿った先のノードが検証済みであるかを確認しながら探索する。

### 特徴

* 再帰関数で記述できないため実装がやや複雑
* メモリの消費量が多い
* 深さ無限でも解に辿りつける
* コストを考慮した探索対象の絞り込み・優先順位付けなどは行わない

### 実装

FILO（First-In Last-Out）のデータ構造つまりキューをOPENリストとして実装する。

```cpp
```
