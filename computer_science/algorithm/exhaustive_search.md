# 全探索

全ての可能性をしらみつぶしに調べる方法。

問題の解の集合を木構造・グラフとして捉えて全探索する場合、次の2種類のアルゴリズムが基本となる。

枝刈りやメモリ使用量を節約した探索方法などは別ページへ。

## 深さ優先探索（DFS : Depth-First Search）

縦型探索とも。

1. 開始ノードから子ノードを辿っていく
1. 子ノードが途切れれば親ノードに戻って別の子ノードを辿る
1. 求めるノードに辿りついたら終了

という手順で解を探索する。

### 特徴

* 再帰関数で簡単に記述できることが多い
* メモリの消費量が少ない
* 深さ無限の場合、解に辿りつける保証がない

単にすべての状態を列挙したいときは実装が楽なのでDFSを使うことが多い。

### 実装

再帰関数もしくは、LIFO（Last-In First-Out）のデータ構造つまりスタックを用いて実装する。

※再帰関数は本質的にはスタックを利用した深さ優先探索の実装の一種と言える

```cpp

```

## 幅優先探索（BFS : Breadth-First Search）

横型探索とも。

1. 開始ノードを1層目、その子ノードを2層目、さらにその子ノードを3層目...とする
1. 1層目の全てのノード、2層目の全てのノード...を順に検証していく
1. 求めるノードに辿りついたら終了

という手順で解を探索する。

### 特徴

* 再帰関数で記述できないため実装がやや複雑
* メモリの消費量が多い
* 深さ無限でも解に辿りつける
* グラフにおける最短経路問題に有利

### 実装

FILO（First-In Last-Out）のデータ構造つまりキューを用いて実装する。

```cpp
```
