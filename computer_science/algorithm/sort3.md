# ソートアルゴリズム3

## 探索木を利用したソートアルゴリズム

### ヒープソート

「最も小さい要素を取り出す」という作業を探索木によって実現したアルゴリズム。
安定でないアルゴリズムである。

木が平衡であれば探索の平均時間計算量・最悪時間計算量はともに $$O(\log n)$$ となるため、ヒープソートは常に $$O(n \log n)$$ で実行できる。
これは最悪時間計算量が $$O(n^2)$$ であるクイックソートと比べると大きな利点である。

* 時間計算量：$$O(n \log n)$$
* 空間計算量：$$O(1)$$

通常、探索木には[プライオリティーキュー](heap.md)を用いる。
プライオリティーキューに用いられる半順序木は対象の配列の上で実装できるため、追加のデータ領域は必要としない。

## 値を直接比較しないソートアルゴリズム

### ビンソート / バケットソート / バケツソート（bin sort / bucket sort）

取りうる値の範囲がわかっているとき、各値の箱（ビン/バケット/バケツ）を用意し、そこへ各要素を収納していくアルゴリズム。

基本となる手順は以下の通り。

1. 取りうる値それぞれについてビンを用意する
2. 対象データの先頭から順に値を検証し対応するビンに要素を格納する

ビンに複数の要素を保持できるようにする、ビンを値の範囲ごとに用意してビンに割り振ってから中の要素をクイックソートで並べ替える、などのバリエーションがある。
キーの重複が多いようなら次の分布数え上げソートの方が性能が良くなる。

いずれの実装でもアルゴリズムに固定値を埋め込むことになるため、対象データの特性（モデル）が判明しているケースでしか利用できない。

* 時間計算量（目安）：$$O(m + n)$$
* 空間計算量（目安）：$$O(m\cdot n)$$ 

※ $$m$$ はビンの数
※ 実装方法により異なる

### 分布数え上げソート（distribution counting sort）

要素の値をキーと見なしてキーの出現回数を数え、その累計を参照することで、あるキーを持つ要素が何番目に来ればいいか検証するアルゴリズム。

基本となる手順は以下の通り。

1. 対象データについて各キーの出現回数を数える
2. 対象データの先頭から順に何番目に並べればよいか検証し、結果のデータ領域に格納する
   * 例えばキー $$k$$ を持つ要素が $$l$$ 回目に現れたとき、「キー $$1 \sim (k-1)$$ を持つ要素の累計」 + $$l$$ 番目に格納すれば良いことがわかる

実装の方針はビンソートとほぼ同じであり、各ビンで出現回数を管理する点が異なる。
キーの重複が少ないようならビンソートの方が性能が良くなる。

ビンソート同様に対象データの特性（モデル）が判明しているケースでしか利用できない。

* 平均時間計算量：$$O(m + n)$$
* 空間計算量：$$O(m\cdot n)$$ 

※ $$m$$ は現れるキーの数
※ 実装方法により異なる

### 基数ソート（radix sort）

数字や文字列など、位によって上位下位の関係が定義できるデータに対して、各位について順に安定なソートを実行することで並び替えるアルゴリズム。
上位桁からソートしていく手法をMSD基数整列法（MSD radix sort）、下位桁からソートしていく手法をLSD基数整列法（LSD radix sort）と呼ぶ。

10進数表記（基数：10）を例に取ると、1の位、10の位、100の位...をキーとしたソートを順に行うことで並び替えを行う。

計算機の場合、整数値の内部表現は2進数のため2進数の基数ソートを利用するのが一般的であり、ビット演算を利用することで高速な実装ができる。
ただし符号ありの場合は最上位ビットが符号を示しているため工夫が必要となる。

* 時間計算量（目安）：$$O(kn)$$
* 空間計算量（目安）：$$O(kn)$$

※ $$k$$ はデータの桁数
※ 実装方法により異なる
