# プロダクションシステム（production system）

1973年にNewellによって提案された、`if-then`ルールに基づいた知識表現並びにそれを用いた推論を行うシステム。
役割によって前向き推論のシステムと後向き推論のシステムに分類される。

プロダクションシステムはルールの結合を動的に行うため、利用者はルールを列挙するだけでよく、大量の知識の処理に向いている。

参考：http://www.ownway.info/Home/cpp/ps/small/1.html

## 構成

プロダクションシステムは以下のコンポーネントから構成される。

* 知識ベース
  * `if-then`ルールを格納する
* 作業領域／ワーキングメモリ
  * 観測された事象や仮説、推論の途中経過を保持する
* 推論エンジン／rule interpreter
  * 知識ベースから知識を取り出し、推論のアルゴリズムを実行する

## 前向き推論／前向き連鎖（forward chaining）

観測された事象に関して順にルールを適用していくことで、観測された事象から何が言えそうかを推論するシステム。

### 知識表現

前向き推論のプロダクションシステムでは、命題 $$A(t)$$ を条件部とし、命題 $$B(t)$$ について操作を施すようなルールすなわち

$$
\mathrm{if} \ A(t)\ \mathrm{then} \ \{\mathrm{make}/\mathrm{modify}/\mathrm{remove \ \ etc...}\}\ B(t)
$$

を`if-then`ルールとして保持する。
これを順に適用することで、新たな事実が追加されたり、既存の事実が否定・修正されたりしながら推論が進んでいく。

### 競合戦略

ルールの結論部に`modify`や`remove`が含まれる場合、どのような順序でルールを適用するかによって結論が変わってくる。

>Example
>* R1 ： $$\mathrm{if} \ A(t)\ \mathrm{then} \ \mathrm{make}\ C(t)$$
>* R2 ： $$\mathrm{if} \ A(t) \wedge B(t)\ \mathrm{then} \ \mathrm{remove}\ C(t)$$

>ここまで極端な例はないようにすべきだが、複雑な系では想定されるケースである。

このような競合に対応する手法を**競合戦略**という。

一般的には、適用可能なルールの**競合集合**（｛ルール, ｛条件となる事実｝｝の形で列挙したもの）から、一定の基準で実行するものを選択する。

このときの基準として、以下の**LEX戦略（lexicographic sort）**が有名である。

1. 既に実行した組は除く
2. 最近追加された事実を条件とする組を採用する
3. ルールの条件部が複雑（詳細）な組を採用する
4. 任意の組を採用する

>Example

>先ほどの例に従うと競合集合は

>$$\{\ \{\mathrm{R1},\{A\}\}, \ \{\mathrm{R2},\{A,B\}\}\ \}$$

>となる。LEX戦略の1,2には当てはまらないものとすれば、3によって $$\mathrm{R2}$$ が採用される。

## 後向き推論／後向き連鎖（backward chaining）

観測された事象と何らかの仮説が与えられたとき、その仮説が満たされうるかを知識に基づいて判断するシステム。

### 知識表現

後向き推論のプロダクションシステムでは、命題 $$A(t)$$ を条件部とし、命題 $$B(t)$$ を結論部とする論理式すなわち

$$
A(t) \rightarrow B(t)
$$

を`if-then`ルールとして保持する。

このとき、推論は与えられた仮説を根としたAND/OR木が恒偽にならないかの検証に帰着できる。
手順は以下のように再帰的に表現される。

1. 仮説を根とする
2. 検証したい命題を結論部に持つルールを探す
    * 見つからなければ検証不可としてルールごと木から取り除く
    * つまりルール $$A(t) \rightarrow B(t)$$ の $$A(t)$$ が証明できないならルールごとなかったことにする
3. 見つけたルールの条件部が真になるか検証する
4. 最終的に根が恒偽にならないかを検証する

また、検証に用いた木を**推論ネットワーク**ということがあり、なぜその仮説が満たされうると考えたかの説明に用いられる。
