# 巡回冗長検査（Cyclic Redundancy Check : CRC）

CRCは[誤り検出・訂正符号](error_detection_and_correction.md)の一種。
右シフトor左シフト、除数、検査器の初期値、前後の処理によっていくつかの規格が存在する。
規格ごとに何ビットの誤り検出・訂正が可能かは変わる。

## 概要

`i`：初期値、`s`：入力ビット列、`d`：nビットの除数（フィルター値）とした右シフト版のアルゴリズムを説明する。

### 送信側

1. `i` `s` `[0 padding:n-1ビット]`を連結したビット列を`a`とする
2. `a`と`d`の最上位にある`1`のビットを揃えるように重ねる
3. 重なった範囲でXORを取り`a`に上書きする
4. 2~3を`a`と`d`の末尾が重なるまで繰り返す
5. 下位n-1ビットをチェックサムとする

これを図示すると次のようになる（`i=00000000`、`s=10011011`、`d=10011`の例）。

```
a = 00000000 10011011 0000
d = 10011

00000000100110110000      00000000000000110000      00000000000000010110
        10011                           10011                      10011
--------------------  ->  --------------------  ->  --------------------
        00000                           01011                      00101

-> 0101がチェックサム
```

### 受信側

1. `i` `s` `[チェックサム]`を連結したビット列を`a`として送信側の2~4と同じ処理を実行する
2. 処理終了後の余りが0なら誤りなし、そうでなければ誤りありと判定する

上と同様の例を図示する。

```
a = 00000000 10011011 0101
d = 10011

00000000100110110101      00000000000000110101      00000000000000010011
        10011                           10011                      10011
--------------------  ->  --------------------  ->  --------------------
        00000                           01001                      00000

-> 余り0なので誤りなし
```

## 演算の数学的な意味

XORの処理は数学的には2を法とする（$$\mathrm{mod}\ 2$$ における）除算に相当する。

説明のため、ビット列を2を法とする剰余環 $$1,x^1,x^2,\cdots$$ を基底とするベクトルと見なし、多項式で表現することにする。
すると`10110100`と`10011`は $$x^7+x^5+x^4+x^2$$ 、$$x^4+x^1+1$$ と表される。
この多項式同士で剰余演算を行うと次のようになる。

$$\begin{eqnarray}
&&(x^7+x^5+x^4+x^2)\ \mathrm{mod}\ (x^4+x^1+1) \\
&=&\{(x^7+x^5+x^4+x^2) - x^3(x^4+x^1+1)\}\ \mathrm{mod}\ (x^4+x^1+1) \\
&=&(x^5-x^3+x^2)\ \mathrm{mod}\ (x^4+x^1+1) \\
&=&(x^5+x^3+x^2)\ \mathrm{mod}\ (x^4+x^1+1) \\
&=&\{(x^5+x^3+x^2)-x(x^4+x^1+1)\}\ \mathrm{mod}\ (x^4+x^1+1) \\
&=&(x^3-x^1)\ \mathrm{mod}\ (x^4+x^1+1)
\end{eqnarray}$$

これは`1`となっている最上位のビットを揃え、XORを取る処理と本質的に同じ。

```
10110100      00101100
10011           10011
--------  ->  -------- -> 1010
00101           00101
```

## 生成多項式

除数を上で述べたような多項式で表現したものを生成多項式と呼ぶ。

例

* 11：`10011`：$$x^4 + x^1 + 1$$
* 98309：`11000000000000101`：$$x^{16}+x^{15}+x^2+1$$

## 理論

除数を素数にしておけばフェルマーの小定理と似たような理屈で、ビット列「入力＋チェックサム」のハミング距離が一定以上に離れることが保証できるらしい。

参考：http://z.apps.atjp.jp/memo/teisei.html

## 実装例

CRC-16-IBMの実装例。
生成多項式は $$x^{16}+x^{15}+x^2+1$$ なので除数は`11000000000000101`。
実装上、先頭ビットは省けるので`1000000000000101`となる。
また左シフトで演算を行うので、フィルターはビットを左右反転させた`1000000000000101`＝`0xA001`となる（2byte）。

データは先頭が右、末尾が左になるように並べてCRCにかける（リトルエンディアンっぽく）。

1bitずつシフトさせながら剰余を計算すると時間がかかるので、0~255を2byteと見立てたときの剰余をテーブルにしておくことで1byteずつシフトさせながら剰余を計算する。
繰り下がりの部分はテーブルに記憶した剰余と次のbyteでXORを取ればよい。

```
B2|             B1|             B0  データ
  |             M1|             M0  マスク
--+---------------+---------------
B2|B1^(B0%[M1 M0])|              0
```

```cpp
#include <iostream>
#include <vector>

class crc16ibm {
    const unsigned short polynomial = 0xA001;
    unsigned short table[256];

public:
    crc16ibm() {
        for (int i = 0; i < 256; i++) {
            unsigned short s = i;
            for (int dig = 0; dig < 8; dig++)
                s = (s & 1) ? (s >> 1) ^ polynomial : s >> 1;
            table[i] = s;
        }
    }

    unsigned short calc_checksum(unsigned char* data, int len) {
        unsigned short div = 0;  //上位バイトの割り算の剰余
        for (int i = 0; i < len; i++)
            div = (div >> 8) ^ table[(div ^ data[i]) & 0xff];
        return div;
    }
};

int main() {
    auto crc16 = new crc16ibm();

    unsigned char data[] = {0x01};
    auto cs = crc16->calc_checksum(data, 1);
    std::cout << "checksum : " << cs << std::endl;

    unsigned char message[3] = {0x01};
    message[1] = cs & 0xff;
    message[2] = (cs >> 8);
    std::cout << "check message : " << crc16->calc_checksum(message, 3)
              << std::endl;

    std::cout << std::endl;
    return 0;
}
```
